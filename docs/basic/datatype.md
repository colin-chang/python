# 数据类型

## 1. 数据类型

Python中主要包含以下数据类型：

* 数字型
  * 整型(int)
  * 浮点型(float)
  * 布尔型(bool)  Python中布尔型于C语言的`真假`类似，0 为False，非0 为Ture
  * 复数型(complex)
* 非数字类型
  * 字符串(str)
  * 列表
  * 元组
  * 字典

```py
# 多变量赋值的两种方式
a = b = c = 1   
a, b, c, d = 1, 3.14, True, "Hello"
```

* Python2.x中整数根据长度分为 int(整型) 和 long(长整型)类型
* Python在定义变量的时不需要指定变量类型。程序运行时解释器会自动根据变量内容推断数据类型。

::: tip type 查看数据类型
[type(object)](../senior/metaclass.md#_2-type-类) 可以查看对象数据类型。type(123) -> int。其实返回的对象的`__class__`属性。
:::

```py
d = 123
type(d)  # int
d.__class__  # int
```

## 2. 数据类型转换

* 不同类型的数字在进行混合运算时，整数将会转换成浮点数进行运算
* bool类型在与数字类型运算时，True为1,False为0
* 字符串类型能直接于数字类型运算

函数|说明
:-|:-
int(x [,base ]) | 将x转换为一个整数
float(x ) | 将x转换为一个浮点数
complex(real [,imag ]) | 创建一个复数，real为实部，imag为虚部
str(x ) | 将对象 x 转换为字符串
repr(x ) | 将对象 x 转换为表达式字符串
**eval(str )** | 将字符串形式的数据，转换为原本的类型
tuple(s ) | 将序列 s 转换为一个元组
list(s ) | 将序列 s 转换为一个列表
chr(x ) | 将一个整数转换为一个Unicode字符
ord(x ) | 将一个字符转换为它的ASCII整数值
hex(x ) | 将一个整数转换为一个十六进制字符串
oct(x ) | 将一个整数转换为一个八进制字符串
bin(x ) | 将一个整数转换为一个二进制字符串

## 3. 对象引用

与C#等强类型语言不同，Python没有值类型，只有引用类型。所有类型数据都存储在堆内存中，而变量则存储于栈内存中指向堆内存地址，**变量的本质是一个指针**，这也是为什么一个变量可以赋值任何数据类型，其背后只是修改了变量指向的内存地址而已。

Python中一个赋值语句的执行过程如下，如 `a = 500`:

* 先执行等号右边的内容。向系统申请一块内存存储500
* 将变量a指向刚上一步申请的内存地址

`id()`函数可以查看对象唯一地址标识，CPython中其表示对象内存地址。Python提供了`is`和`is not`操作符来测试两个变量是否指向同一个地址。

```py
a = 10  # 开辟堆内存空间存储10，并将变量名a指向堆内存地址
b = a   # 将a指向的堆内存地址赋值给b，此时b与a指向同一个地址
a is b # True
id(a) == id(b) # True
```

* `==` 验证内容是否相同
* `is` 验证地址是否相同

`a is b`等价与`id(a) == id(b)`。

出于内存优化考虑，[-5,256]之间的小整数,单个字符,相同字符串,三种变量的引用比较特殊,具体可参阅[对象池与intern](../senior/intern.md)。

## 4. 可变类型/不可变类型

可变类型指声明之后可以修改的数据类型，不可变类型则相反。Python中**只有列表和字典是可变类型。**

由于Pyton的地址引用，可变类型内容修改后，所有指向它的变量都会同步修改，由此可变类型可以实现C#等语言当中引用地址传递的效果。

不可变类型内容声明后不能修改，对变量的赋新值则会开辟新的堆内存以存储新值并将变量名指向新的地址，而之前堆内存中存储的数据并没有改变。由此不可变类型可以实现C#等语言值传递的效果。当旧的堆内存地址没有任何变量指向时，会被[GC](../senior/gc.md)并释放内存。

```py
a = 10
b = a   # 此时b指向与a相同的存储10的内存地址
b = 20  # int为不可变类型，赋值20会开辟新内存存储20并将其新地址赋值给b
b is a # False  a指向存储10的内存地址，b指向存储20的内存地址

lst1 = [1, 2]
lst2 = list1   # list2与list1指向同一内存地址
lst2[0] += 1   # 列表为可变类型，修改会直接在实际数据存储的堆内存中进行，所有指向此地址的变量都会取到修改后的值
lst2 is lst1  # True list1和list2指向内存地址未发生变化，两者依然相同
```
